import { PayoutService } from './payout.service';
import { BalanceService } from './balance.service';
import { LedgerService } from './ledger.service';
import { ReconciliationService } from './reconciliation.service';
import { FinancialAnalyticsService } from './analytics.service';
import { FinancialAutomationService } from './automation.service';
import { PrismaService } from '../prisma/prisma.service';
import { PayoutRequestStatus } from '@prisma/client';
export declare class AdminFinancialController {
    private readonly payoutService;
    private readonly balanceService;
    private readonly ledgerService;
    private readonly reconciliationService;
    private readonly analyticsService;
    private readonly automationService;
    private readonly prisma;
    private readonly logger;
    constructor(payoutService: PayoutService, balanceService: BalanceService, ledgerService: LedgerService, reconciliationService: ReconciliationService, analyticsService: FinancialAnalyticsService, automationService: FinancialAutomationService, prisma: PrismaService);
    getAllBalances(page?: string, limit?: string): Promise<{
        data: ({
            user: {
                email: string;
                full_name: string;
            };
        } & {
            id: string;
            created_at: Date;
            updated_at: Date;
            currency: string;
            user_id: string;
            available_balance: import("@prisma/client/runtime/library").Decimal;
            pending_balance: import("@prisma/client/runtime/library").Decimal;
            total_earned: import("@prisma/client/runtime/library").Decimal;
            total_withdrawn: import("@prisma/client/runtime/library").Decimal;
            last_payout_at: Date | null;
        })[];
        total: number;
        page: number;
        limit: number;
    }>;
    getLedgerHistory(balanceId: string, page?: string, limit?: string): Promise<{
        data: {
            id: string;
            description: string;
            created_at: Date;
            currency: string;
            type: import(".prisma/client").$Enums.LedgerEntryType;
            amount: import("@prisma/client/runtime/library").Decimal;
            metadata: import("@prisma/client/runtime/library").JsonValue;
            transaction_id: string | null;
            seller_balance_id: string;
            source: import(".prisma/client").$Enums.LedgerEntrySource;
            balance_before: import("@prisma/client/runtime/library").Decimal;
            balance_after: import("@prisma/client/runtime/library").Decimal;
            sequence: number;
            previous_hash: string | null;
            hash: string;
            payout_request_id: string | null;
            created_by_id: string | null;
        }[];
        total: number;
    }>;
    getPayouts(status?: PayoutRequestStatus, page?: string, limit?: string): Promise<{
        data: ({
            seller_balance: {
                id: string;
                created_at: Date;
                updated_at: Date;
                currency: string;
                user_id: string;
                available_balance: import("@prisma/client/runtime/library").Decimal;
                pending_balance: import("@prisma/client/runtime/library").Decimal;
                total_earned: import("@prisma/client/runtime/library").Decimal;
                total_withdrawn: import("@prisma/client/runtime/library").Decimal;
                last_payout_at: Date | null;
            };
            seller: {
                email: string;
            };
        } & {
            id: string;
            created_at: Date;
            updated_at: Date;
            currency: string;
            status: import(".prisma/client").$Enums.PayoutRequestStatus;
            amount: import("@prisma/client/runtime/library").Decimal;
            payment_method: string;
            payment_details: import("@prisma/client/runtime/library").JsonValue;
            metadata: import("@prisma/client/runtime/library").JsonValue;
            seller_id: string;
            failed_at: Date | null;
            failure_reason: string | null;
            retry_count: number;
            max_retries: number;
            approved_at: Date | null;
            approved_by_id: string | null;
            rejection_reason: string | null;
            requested_at: Date;
            rejected_at: Date | null;
            processing_started_at: Date | null;
            completed_at: Date | null;
            provider: string | null;
            provider_payout_id: string | null;
            provider_response: import("@prisma/client/runtime/library").JsonValue | null;
            reconciled: boolean;
            reconciled_at: Date | null;
            next_retry_at: Date | null;
            notes: string | null;
            seller_balance_id: string;
            rejected_by_id: string | null;
            reconciled_by_id: string | null;
        })[];
        total: number;
    }>;
    approvePayout(id: string, req: any): Promise<{
        id: string;
        created_at: Date;
        updated_at: Date;
        currency: string;
        status: import(".prisma/client").$Enums.PayoutRequestStatus;
        amount: import("@prisma/client/runtime/library").Decimal;
        payment_method: string;
        payment_details: import("@prisma/client/runtime/library").JsonValue;
        metadata: import("@prisma/client/runtime/library").JsonValue;
        seller_id: string;
        failed_at: Date | null;
        failure_reason: string | null;
        retry_count: number;
        max_retries: number;
        approved_at: Date | null;
        approved_by_id: string | null;
        rejection_reason: string | null;
        requested_at: Date;
        rejected_at: Date | null;
        processing_started_at: Date | null;
        completed_at: Date | null;
        provider: string | null;
        provider_payout_id: string | null;
        provider_response: import("@prisma/client/runtime/library").JsonValue | null;
        reconciled: boolean;
        reconciled_at: Date | null;
        next_retry_at: Date | null;
        notes: string | null;
        seller_balance_id: string;
        rejected_by_id: string | null;
        reconciled_by_id: string | null;
    }>;
    rejectPayout(id: string, reason: string, req: any): Promise<{
        id: string;
        created_at: Date;
        updated_at: Date;
        currency: string;
        status: import(".prisma/client").$Enums.PayoutRequestStatus;
        amount: import("@prisma/client/runtime/library").Decimal;
        payment_method: string;
        payment_details: import("@prisma/client/runtime/library").JsonValue;
        metadata: import("@prisma/client/runtime/library").JsonValue;
        seller_id: string;
        failed_at: Date | null;
        failure_reason: string | null;
        retry_count: number;
        max_retries: number;
        approved_at: Date | null;
        approved_by_id: string | null;
        rejection_reason: string | null;
        requested_at: Date;
        rejected_at: Date | null;
        processing_started_at: Date | null;
        completed_at: Date | null;
        provider: string | null;
        provider_payout_id: string | null;
        provider_response: import("@prisma/client/runtime/library").JsonValue | null;
        reconciled: boolean;
        reconciled_at: Date | null;
        next_retry_at: Date | null;
        notes: string | null;
        seller_balance_id: string;
        rejected_by_id: string | null;
        reconciled_by_id: string | null;
    }>;
    processPayout(id: string): Promise<{
        id: string;
        created_at: Date;
        updated_at: Date;
        currency: string;
        status: import(".prisma/client").$Enums.PayoutRequestStatus;
        amount: import("@prisma/client/runtime/library").Decimal;
        payment_method: string;
        payment_details: import("@prisma/client/runtime/library").JsonValue;
        metadata: import("@prisma/client/runtime/library").JsonValue;
        seller_id: string;
        failed_at: Date | null;
        failure_reason: string | null;
        retry_count: number;
        max_retries: number;
        approved_at: Date | null;
        approved_by_id: string | null;
        rejection_reason: string | null;
        requested_at: Date;
        rejected_at: Date | null;
        processing_started_at: Date | null;
        completed_at: Date | null;
        provider: string | null;
        provider_payout_id: string | null;
        provider_response: import("@prisma/client/runtime/library").JsonValue | null;
        reconciled: boolean;
        reconciled_at: Date | null;
        next_retry_at: Date | null;
        notes: string | null;
        seller_balance_id: string;
        rejected_by_id: string | null;
        reconciled_by_id: string | null;
    }>;
    runSystemWideReconciliation(): Promise<{
        total: number;
        failures: import("./reconciliation.service").ReconciliationReport[];
    }>;
    checkReconciliation(balanceId: string): Promise<import("./reconciliation.service").ReconciliationReport>;
    simulateCorruption(balanceId: string, amount: number): Promise<import("./reconciliation.service").ReconciliationReport>;
    getAnalyticsDashboard(): Promise<{
        revenue: import("@prisma/client/runtime/library").Decimal;
        liabilities: import("@prisma/client/runtime/library").Decimal;
        payouts: import("@prisma/client/runtime/library").Decimal;
        velocity: number;
        timestamp: Date;
    }>;
    triggerAutomation(workflow: string, dryRun?: boolean): Promise<{
        status: string;
        workflow: string;
        dryRun: boolean;
    }>;
    enableAutomation(enabled: boolean): {
        status: string;
        enabled: boolean;
    };
}
